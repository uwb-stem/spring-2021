{
    "csse": [
        {
            "time": "12:30 PM - 12:45 PM",
            "projectId": "room-2-1230",
            "title": "Software Developer Internship at Encora",
            "studentName": "Steve Bollman",
            "studentMajor": "CSSE",
            "projectType": "Sponsored Internship - Liberty Mutual",
            "facultyAdvisor": "Dr. Laurie Anderson",
            "posterLink": "posters/csse/bollmansteven.jpg",
            "abstract": "Encora is an app based, eco-positive reusable container company aimed at reducing waste. Encora currently uses to-go containers that have unique QR codes and matching RFID codes attached to them, the containers are checked out through a participating food & beverage vendor by scanning the containers QR code from the Encora app, and then the containers are returned to a bin. The containers are scanned back into the database system using the QR code or RFID module then collected and cleaned. Finally, the containers are returned to vendors for distribution.\n\nThe project I was engaged in was the implementation of a smart return receptacle, the AutoDrop. The AutoDrop is an RFID powered return receptacle that stores and provides data about the dirty to-go containers. The AutoDrop has 3 separate motor-driven doors that open as the to-go containers approach, each door is assigned to a certain type of container and will only open once the RFID antenna recognizes a container within 5 feet and has the correct encoded tag information.  The AutoDrop has sensors installed to determine factors such as how full the container is and if the receptacle should open for container insertion. The data informing how full the receptacle is and when containers are returned is then sent to the cloud and updates a database, which is then reflected in the mobile and web application. This allows maintenance to be aware of when to clean the receptacles and to inform end-users that the return of their container was successful. The returns are also used to keep count of billing for vendors. \n\n The role I specifically played was creating a proof-of-concept prototype for a Kickstarter program at the San Diego International Airport. I created the plans and did the research and development of this prototype of the AutoDrop that ended up going live with real users in the San Diego Airport, and eventually won a contract for this product at the airport. "
        },
        {
            "time": "12:45 PM - 1:00 PM",
            "projectId": "room-2-1245",
            "title": "Designing Safety Critical UI: A Student's Approach",
            "studentName": "Benjamin Holmes",
            "studentMajor": "CSSE",
            "projectType": "Sponsored Internship - Doosan Grid Tech",
            "facultyAdvisor": "Dr. Laurie Anderson",
            "posterLink": "posters/csse/benjaminholmes.jpg",
            "abstract": "It is imperative that the fundamental components of any safety critical application are highly reliable and well-constructed. Beginning in June 2020 I started my internship at Doosan GridTech. Prior to receiving the internship, I was sure that my experience and interviewing performance would not be enough to secure the position. Throughout the internship, these feelings persisted, and I have had to learn how to navigate and grow out of them. Overcoming and growing confidently step into work regardless of my perceived ability to accomplish it.\n\nI began my onboarding working on the OneUI reports feature. Impressed with my work and ability to pick up work quickly I was able to step into a part time roll where I have worked on a variety of features that will be utilized in production. \n\nDuring my internship, a key team member left the OneUI team suddenly right before launching our product and many of his responsibilities fell on me. With much less experience and engineering capabilities, I had to pick up where he left off. \n\nI used my skills as a learner, developed at university, to utilize the resources available to me such as my more experienced co-workers and online educational sources. This allowed me step into a key features ownership and support my team members on everything from design work to app wide error handling.\n\nWe are currently about to launch the alarms feature (the feature I inherited) I completed the feature mostly independently and met the appropriate deadlines and specifications provided by my manager. I went from feeling completely inadequate in my role to growing in confidence and recognizing my existing skills and my ability to learn things quickly. This was a result of open and honest communication with my coworkers and manager. This internship pushed me to grow into a highly teachable developer who can take on something as important as safety critical UI, something I never thought I would do this early in my career."

        },
        {
            "time": "1:00 PM - 1:15 PM",
            "projectId": "room-2-100",
            "title": "Strings and Pins",
            "studentName": "Alex Van Matre",
            "studentMajor": "CSSE",
            "projectType": "Faculty Research",
            "facultyAdvisor": "Dr. Munehiro Fukuda",
            "posterLink": "posters/csse/vanmatrealex.jpg",
            "abstract": "With the increasing demand for cloud computing, the demand for distributed computing increases as well. This demand comes from the need for better libraries that can help run multiple computer system algorithms. The purpose of my program is to take the StringsAndPins algorithm, conceived by the University of Bremen, and implement their algorithm within the University of Washington, Bothell Distributed System Lab’s MASS library to help highlight the increasing features and excelling execution performance of applications written for the library.\n\nImagine the strings and pins algorithm in a real-world scenario such as a map. The intersections would be the pins and the roads between those intersections would be the strings. You would define a source and a destination spot on the map and this is the route for which we are going to try and find the shortest path. Next, you would apply a force to the destination pin and pull it away from the source pin while the source pin stays constant. You would pull on the destination pin, which recursively would tug on strings until it reached the source pin, pulling other pins along and creating one taught line. This one, final, taught line is the shortest path possible between these two points.My program’s execution performance showed three main factors that affected runtime when scaling the program. The first and least consequential was the machine scaling. There were rather minimal variations in the runtime when looking at the differences of pins scaled over a different amount of machines. The second, which had quite an impact, was the distance between the source and destination pin. The greater the distance, the more cycles the program tended to take to finish, which increased the overall runtime. The final, most impactful variable, that seemed to have the most impact, was the number of pins that existed within the path between the source and the destination. With each additional pin that existed in the path, another computation time was added per cycle, per pin, scaling the runtime quite exponentially.The results demonstrated the somewhat expected scaling results of the program. It created an efficient way to measure the shortest path between two points, conceptualized in a two-dimensional view, ran in a distributed systems environment."
        },
        {
            "time": "1:15 PM - 1:30 PM",
            "projectId": "room-2-115",
            "title": "Multi-Agent System Simulation between Mass C++, Flame and Repast HPC",
            "studentName": "Nathan Wong",
            "studentMajor": "CSSE",
            "projectType": "Faculty Research",
            "facultyAdvisor": "Dr. Munehiro Fukuda",
            "posterLink": "posters/csse/wongnathanthomas.PNG",
            "abstract": "Agent-based simulations are able to simulate complex models in order to help enable us in making strategic decisions. Due to the multiple usages of these simulations, it has become one of the many important tools that researchers are using. However, there are many different agent-based libraries, and therefore it is hard to determine which library best suits the researchers needs. In order to help non-computing scientists and computing scientists alike we are benchmarking three different agent-based modeling libraries towards seven different benchmarks. These benchmarks will be used to compare towards social, behavioral, economical/environmental, disease and neural engineering applications. The benchmarks that were chosen for this research are the following: Game of Life, Social Network, Tuberculosis, Brain Grid, Bail-in Bail-out, MATSIM and VDT. The libraries that are being judged is Flame, MASS C++ and Repast HPC. These libraries work in different ways, for instance Flame uses a messaging board in order to communicate with the agents. The agents then decide what to do with the messages that they receive. MASS C++ utilizes a distributed array known as places and allow agents to migrate between these places. Finally, Repast HPC allows agents to be shared, requested or moved between each process. Since these libraries work in different fashions, it is therefore useful to be able to see which applications one might be more prevalent over the other."
        },
        {
            "time": "1:30 PM - 1:45 PM",
            "projectId": "room-2-130",
            "title": "Green AI: Anomaly Detection",
            "studentName": "Gabriel Acuna",
            "studentMajor": "CSSE",
            "projectType": "Sponsored Internship: Microsoft",
            "facultyAdvisor": "Dr. Nancy Kool",
            "posterLink": "posters/csse/acunagabriel(final).jpg",
            "abstract": "Microsoft’s Deep Learning project sponsors multiple University of Washington student-driven teams (graduate and undergraduate) mentored by machine learning engineers at Microsoft. The “Green AI: Anomaly Detection” team seeks to evaluate Anomaly Detection model efficiency under various conditions to relate to the correlation between computational time and carbon footprint to facilitate Microsoft’s mission to be carbon negative by 2030. Greenhouse emissions coming from data centers and similar sources of large-scale computation currently add to the concentration of greenhouse gasses in the atmosphere which dramatically influences climate change. Leveraging the power and tools of Azure Machine Learning, the team is performing a cost/benefit analysis of Anomaly Detection over different baseline architectures to integrate with the cost, power, and carbon telemetry of AzureML. Final team deliverable will be a GitHub repository under github.com/Microsoft that showcases and provides proof of concept and a starting point for Microsoft customers by illustrating product customizability for various Anomaly Detection algorithms. The team has been able to achieve an average 95% Anomaly Detection model accuracy with Anomaly Detection algorithms: Isolation Forest, Autoencoder Neural Network, Principal Component Analysis, and Support Vector Data Description for the “KDD Cup 1999” and “UNSW-NB15” datasets. Current findings have shown that researched Anomaly Detection algorithms perform generally well regarding accuracy, except for a few low max samples and low max features models. Consistently generating high accuracy can be achieved by using low max features, high max samples, and an intermediate number of estimators. Further analysis found that that using high max samples and medium max features with a small number of estimators can maintain high accuracy while minimizing run time. Case study ends June 30, 2021; therefore, final published findings are still in works.\n\nSuccessful deliverables in this project have been achieved by researching and developing a deeper understanding of: computation carbon footprint, machine learning algorithms, Python for data science, small development team dynamic, Azure Machine Learning Studio tools, Python machine learning frameworks & libraries, and version control systems."
        },
        {
            "time": "1:45 PM - 2:00 PM",
            "projectId": "room-2-145",
            "title": "Reservation App for Mobile Devices",
            "studentName": "Eric Lin",
            "studentMajor": "CSSE",
            "projectType": "Individual Project - Student Defined",
            "facultyAdvisor": "Dr. Arnie Lund",
            "posterLink": "posters/csse/lineric.png",
            "abstract": "The Rezerv App is designed to address and alleviate pain points that have arisen regarding reservations for businesses due to the COVID-19 pandemic. WIth limited capacities and more businesses requiring a reservation, our app hopes streamline the process by creating a space that businesses can utilize to customize their own time slots as well as creating a single platform that customers can use to easily reserve spaces in all of their favorite businesses.\n\nOur personal goals were to develop skills pertinent to the industry including backend work, UI design, user research, and app development. We utilized tools new to both of us such as Firebase, Android Studio, Android Emulator, and Flutter, and worked collaboratively to tackle the challenges of working in a new environment with new tools\n\nWe utilized agile methodologies to provide a more flexible working environment during this quarter. We used sprint planning to create goals and steps to reach and met regularly through each week to discuss critical issues that may have arisen and make sure we were both on track to meet our goals.\n\nWhen designing our software, we used many skills we gained from courses here at UWB such as Object-Oriented Programming (OOP), data structures, and databases. We also used many skills gained from courses not pertaining as much to the code itself as the aforementioned Agiled Software Development Lifecycle method, technical writing to navigate the channels of communication between ourselves, testers, sponsose, and faculty , and most importantly use research which helped us to survey our potential market and cater our app towards paint points experienced by people in the real world."
        },
        {
            "time": "2:00 PM - 2:15 PM",
            "projectId": "room-2-200",
            "title": "Reservation App for Mobile Devices",
            "studentName": "Bryan Song",
            "studentMajor": "CSSE",
            "projectType": "Individual Project - Student Defined",
            "facultyAdvisor": "Dr. Arnie Lund",
            "posterLink": "posters/csse/songbryanehaw.png",
            "abstract": "The Rezerv App is designed to address and alleviate pain points that have arisen regarding reservations for businesses due to the COVID-19 pandemic. With limited capacities and more businesses requiring a reservation, our app hopes to streamline the process by creating a space that businesses can utilize to customize their own time slots as well as creating a single platform that customers can use to easily reserve spaces in all of their favorite businesses.\n\nOur personal goals were to develop skills pertinent to the industry including backend work, UI design, user research, and app development. We utilized tools new to both of us such as Firebase, Android Studio, Android Emulator, and Flutter, and worked collaboratively to tackle the challenges of working in a new environment with new tools.\n\nWe utilized agile methodologies to provide a more flexible working environment during this quarter. We used sprint planning to create goals and steps to reach and met regularly through each week to discuss critical issues that may have arisen and make sure we were both on track to meet our goals.\n\nWhen designing our software, we used many skills we gained from courses here at UWB such as Object-Oriented Programming (OOP), data structures, and databases. We also used many skills gained from courses not pertaining as much to the code itself such as the aforementioned Agile Software Development Lifecycle method, technical writing to navigate the channels of communication between ourselves, testers, sponsors, and faculty, and most importantly user research which helped us to survey our potential market and cater our app towards pain points experienced by people in the real world."
        },
        {
            "time": "2:15 PM - 2:30 PM",
            "projectId": "room-2-215",
            "title": "T4G LeetCode Programming",
            "studentName": "Sonlam Nguyen",
            "studentMajor": "CSSE",
            "projectType": "Sponsored Internship",
            "facultyAdvisor": "Dr. Yusuf Pisan",
            "posterLink": "posters/csse/sonlamnguyen.jpg",
            "abstract": "The ideal route for an up and rising software developer is to get an internship in their early years and then leverage that experience into getting a job in the industry. Companies such as Microsoft, Google, Amazon and Facebook all have internships targeting students who are juniors pursuing their bachelors. The problem is that many students do not have the confidence to attempt to take on some of these infamously difficult interviews, nor do they have the skillset if they’re only studying within their coursework.\n\nA resource heavily used by individuals studying for the technical interview is a book called “Cracking the Coding Interview” by Gayle Laakmann. According to her, the concepts needed for the interview are: Linked List, Trees, Graphs, Stacks & Queues, Heaps, Hash Tables, Breadth First Search, Depth First Search, binary Search, Merge Sort, Quick Sort, Bit Manipulation, Recursion, Dynamic Programming and Big O Time & Space. The interviewer will ask a question that will involve a number of these concepts in one problem so it is extremely important to have complete mastery over all of the subjects.\n\nAlthough the CSSE department includes two data structure and algorithms courses, these courses only scratch the surface of data structures and algorithms. They generally only give one program per data structure for students to master them. This does help in giving fundamentals, but it does not always help with how the data structure will apply or when to use them when given a technical interview problem. In addition to this, the duration of the two fundamental courses span past the peak hiring periods that companies have in the late Fall to the early Winter.\n\nTo help with this my team T4G LeetCode Programming created the Stepik learning course. This is a fully self paced online educational course. Problems are pulled from LeetCode, the world’s most popular website for developers to practice their coding skills. The problems are then solved and dissected by team members to write in-depth lessons about. As group members, we solve each problem from scratch and write lessons geared towards students who are also not familiar with the concept. We as team members are not special by any means. We are students who struggle with these problems as well and take long periods of time to figure some out. By doing this, we know where students receiving the lesson are struggling and common pitfalls they fall into.\n\nThe lessons are written into “steps” which the user can either follow from start to end, or skip to steps that they feel lost on. There is also active engagement through steps that require engagement from the user, and a comments section. We hope that by writing these lessons students are able to gain confidence in their coding skills and challenge the unknown."
        },
        {
            "time": "2:30 PM - 2:45 PM",
            "projectId": "room-2-230",
            "title": "Leetcode Problem Sovling Workshops",
            "studentName": "Taylor Eyler",
            "studentMajor": "CSSE",
            "projectType": "Faculty Research",
            "facultyAdvisor": "Dr. Yusuf Pisan",
            "posterLink": "posters/csse/eylertaylorkaur.png",
            "abstract": "The U.S. Bureau of Labor Statistics projects employment in computer and information technology occupations to grow 11 percent from 2019 to 2029, which is a much faster growth rate average when compared across all occupations. In a world that is increasingly dependent on computers, the employment outlook for computer science students should continue to be a bright spot in the jobs sector. Despite this, computer science majors have one of the highest unemployment rates post-graduation. In 2020, the unemployment rate of newly graduated computer science majors was 4.5% compared to an overall unemployment rate of 2.8%. Data trends suggest that this unemployment rate will continue to grow as universities struggle to adapt to the rapidly changing landscape of the computer science hiring process.\n\nMore and more, computer science majors are being asked to demonstrate skills beyond what is generally emphasized in most computer science majors during a technical interview, particularly in the realm of creative problem solving. To bridge the gap between what is taught in university and what is expected in a technical interview, myself and other members of the Tech for Good research group at University of Washington Bothell hosted problem solving workshops and online courses.\n\nOver the span of two quarters, I hosted 14 problem solving workshops focused on identifying approaches to data structures and algorithms questions commonly asked in technical interviews. In post-workshop surveys, 80% of participants who were currently enrolled in CSS 342 or CSS 343 reported that they learned new information that had not yet been covered in their studies at UWB and 100% of the participants reported that they felt more prepared for technical interviews after attending the workshops. Among participants who had already completed CSS 342 and CSS 343, 71% reported that they learned something new and 86% reported feeling more prepared for technical interviews after attending the workshops. The workshops fill a clear need in students’ education. Adapting the undergraduate curriculum to align with the demands of the computer science industry is the only way to ensure every student is successful after graduation."
        },
        {
            "time": "2:45 PM - 3:00 PM",
            "projectId": "room-2-245",
            "title": "100 Unity Mechanics for Programmers",
            "studentName": "Jacob Pierce",
            "studentMajor": "CSSE",
            "projectType": "Faculty Research",
            "facultyAdvisor": "Dr. Yusuf Pisan",
            "posterLink": "posters/csse/piercejacobw.jpg",
            "abstract": "Currently, there are not resources to find straightforward Unity mechanic tutorials that are comprehendible, correct, and realistic. For example, there are YouTube videos that are lengthy and hard to follow for basic mechanics. Various forums such as Stack Overflow can also be more harmful to novice game developers by being outdated, time-consuming, or providing code snippets without being fully tested. Using the resources previously mentioned, these can make learning Unity a greater challenge than it needs to be, and cause discouragement among new game developers. 100 Unity Mechanics for Programmers strives to change these hardships by offering 100 uncomplicated game mechanics, of which all include: step-by-step tutorials, working demonstrations, and source codes for the developer to learn from and experiment with.\n\nWith previous game development experience and wanting to improve my skills, I joined this project last quarter to continue the work that was started by the previous capstone student. Last quarter, I worked alongside another capstone student to create these mechanics. We would communicate to each other to ensure that our in-progress mechanics were not redundant.\n\nWhen brainstorming new mechanics to implement, I would think back to when I took Introduction to Game Development and the mechanics that I used or saw other game developers use. Another way I would come up with mechanic ideas was from video games that I was currently playing or games I had played before. Once I had an idea, I would then outline the idea by writing down the process of making it to make sure it was plausible and reasonable. After I was done implementing the mechanic, I created the step-by-step tutorial of what I did and created a WebGL demo of it. All of this was then compiled together and uploaded to the GitHub repository with the previously implemented mechanics.\n\nAlthough the list of 100 mechanics is completed, future capstone students can be tasked to refine, improve, and keep each mechanic up to date, with the hopes of assisting novice game developers. The overall goal of the project is to maintain a helpful resource of basic and simple game mechanics to new developers. "
        },
        {
            "time": "3:00 PM - 3:15 PM",
            "projectId": "room-2-300",
            "title": "Deconstructing a Technical Problem",
            "studentName": "Scott Shirley",
            "studentMajor": "CSSE",
            "projectType": "Faculty Research",
            "facultyAdvisor": "Dr. Yusuf Pisan",
            "posterLink": "posters/csse/shirleyscott.png",
            "abstract": "Companies routinely use technical interviews when hiring software developers.  As the tech industry has grown, these technical interviews have become increasingly competitive.  Even students who have done well in courses, have to study explicitly for these technical interviews over several months.\n\nOur solution to addressing these concerns was to develop a course designed to help third and fourth year students practice common types of interview questions.  These lessons so far consist of 117 common interview questions from the website LeetCode.com in various topics that include strings, arrays, linked lists, binary search trees, and more.  To date, the course has had 196 registered students.\n\nSolving these problems, often under a time limit and in front of others, can be intimidating.  Knowing how to implement a specific data structure or being able to calculate runtime complexity of an algorithm is only half of answering technical interview questions.  Students need to be able to thoroughly explain their process while arriving at their solution.  Technical interviews are as much about showing that you are able to work through a problem as they are about finding the correct solution.  Often there is more than one solution to a problem and having the ability to explain one’s choice is a crucial process.\n\nThis project aims to assist UW students prepare for technical interviews by not just practicing coding problems, but offering detailed explanations as to how the solution was obtained.  Practicing for a technical interview usually involves working through several common questions and checking for accuracy. Our approach seeks to help students develop the skills required to decompose any problem and solve it systematically.  Developing this skill set assists students in succeeding at technical interviews. Additionally, this course has helped students develop problem-solving skills that will help them throughout their education and careers in CS."
        }
    ]
}